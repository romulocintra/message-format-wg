20 November 2023 | MessageFormat Working Group Regular Teleconference

### Attendees
- Addison Phillips - Unicode (APP) - chair
- Tim Chevalier - Igalia (TIM)
- Elango Cheran - Google (ECH)
- Staś Małolepszy - Google (STA)
- Eemeli Aro - Mozilla (EAO)
- Richard Gibson - OpenJSF (RGN)
- Zibi - Amazon (ZBI)


Scribe: TIM

## Topic: Agenda Review

## Topic: Info Share

ECH: Upcoming hybrid event [Face/Interface](https://face-interface.com/) for encoding & input methods - focused on digitally disadvantaged languages. There is a livestream; no cost. Might be lower level in the i18n stack

## Topic: Action Item Review

APP: survey for f2f dates - Trying to work out funding. Have calls still pending. Trying to schedule around TC39 in San Diego; include weekends?

EAO: Fine w/ weekend after, not weekend before

ECH: Weekend should be fine for MIhai

RGN: Can’t make it

TIM: Might be able to

STA: Might be able to

TC39 meets Tuesday, 6 Feb to Thursday 8 Feb in San Diego. We’ve been asked to schedule around that. Main question is whether to include the weekend, e.g. 31 Jan to 4 Feb. How many days of F2F do we want? (avoid 3-4)

## Topic: Progressing to Done

The main blockers appear to be the following:
- Beautification of the syntax discussion
- What’s in a name? (Does NCName fix our woes? Go to UAX31? what?)
- Quoting
- Spannables
- Format-to-Parts
- Expression Attributes
- Registry and default functions
- Implementation and testing

APP: Tried to make list of key stumbling blocks to solve. Concerned about making a decision that we immediately re-visit. Stick to things unless we have a good reason not to. Anything to add to list?

EAO: Not seeing expression attributes

APP: ok - need to put quoting? (Yes)

STA: Can either of you talk a little more about the external pressure, goal and deliverable? Are we expected to, whatever we ship in the spring, call it the final version of the standard? Or is there still more time to allow for listening to user feedback before we call it done?

APP: Open to hearing user feedback, but at some point, if you’re going to ship, you’re creating a backwards compatibility trap. At some point you have to commit to what you’ve done. We’ve said we want to release in the spring; if we miss that date by a small margin, not the end of the world. I don’t want to continue on the same path of taking a couple years and studying to death. At some point, people will go make another standard. I want us to be efficient; if we miss an arbitrary date b/c of housekeeping, fine, but – if we took the spec today and implemented it, people would take it. We have improvements to do before shipping, but need to work towards done and not re-examine everything w/o a good reason.

EAO: My sense is the same, but on a technicality, I think we will be releasing a release candidate. It should be releasable but there’s a possibility of a window for sufficient external pressure to be introduced for us to change something. Hopefully not too big, but there’s a window to get input after release and hopefully validate our decisions, still can apply changes.

STA: But we already did a technical preview, right?

APP: We’re going to release something we think is done; others will comment, if they’re sufficiently unhappy, we would re-study it. I don’t think we would release something thinking there’s more to do.

STA: I understand the push to get to done. My question was more about whether there is any possibility at all to change some decisions in case we hear very strong feedback

APP: Absolutely - but as a WG we would not be meeting every week to hammer away on it. Would be collecting feedback and listening

ECH: As far as the push to done, I’m glad there’s agreement. If you remember in 2020 we were talking about MessageFormat for the entire year, and in the fall, strong concerns surfaced about how we can’t release something that’s not perfect. Can never change, has to be adaptable to all future requirements known and unknown, and if it can’t, it would be a failure. That’s not a way to do software, but those concerns were concerning people enough to hang up progress. I’m glad we’re not in that mode. As far as technical preview implementation in ICU, we have the ICU4J code implementing syntax for August 2022. No ICU4C yet. We prefer releasing ICU code that’s in sync with each other and because of the churn, it makes it more difficult.

TIM: ICU4C implementation is there, but review process is still early on

STA: Difference between general software and what we do, b/c we create public APIs for an industry known for being slow. Our ability to course-correct after we ship is very limited. We won’t be able to iterate, will need to accrue and keep backwards compatibility. I know we’ve been here for 3+ years but these were different 3 years. Only recently that we started meeting every week. Addison has been chair for only part of that. Some of the time was on a very different cadence. We made progress on a very different pace. I don’t expect us to need another 3 years.

APP: But let’s not fall into the trap of sliding the window down. We will want feedback, but needs to be constructive feedback to tell us, for example, you really made the wrong decision on quotes. But not necessarily a complete redesign, unless people tell us this is totally unacceptable and we won’t implement it.

ECH: Do want to point out that we’ve had periods of months where we didn’t meet weekly. Not a new thing, and it’s more about the mindset. It’s a matter of making sure we make progress and knowing what’s substantive. We have feedback from the Seville event meant to get us towards that, which reopened some issues. Can’t go through that too many times. Can’t go through a year of relative stability and up-end it and do that multiple times.

## Topic: Beautification of the Syntax

Having decided the above, changes to remove uglification of the syntax.

Code-Mode Introducer Design: https://github.com/unicode-org/message-format-wg/pull/521 
Balloting: https://github.com/unicode-org/message-format-wg/issues/525
Discussion: https://github.com/unicode-org/message-format-wg/issues/526

APP: we did some balloting; D was first. D was dot in front of keywords. I was surprised that A had such a strong showing and came in second, simply because we chose that for its relative lack of beauty. I guess people appreciate consistency w/ quoting. We voted on it, but I want to check with the group: are we happy to proceed with D? Do we want to proceed, or does anyone want to discuss?

STA: I have another comment; this ballot has much lower attendance than the previous one. I don’t think it was a ballot to make a choice, but from a technical discussion. I wanted to make that clear. I put D as my third choice, I can see how it works and I think it’s workable. I can live with it. I am concerned about the promise that we’re breaking about text-first mode with D, and that is that I think there’s something about it – might be completely personal – that doesn’t look much like code to me. I think that in text-first mode, the syntax that gets us into code mode should be more distinct. That’s why I preferred parens/brackets/any sort of wrapping. Curious if others agree

APP: I think that’s a fair observation; we could discuss what sigil to use. We adopted dot sigil sort of late in the discussion. There were some suggestions; Martin Duerst likes >, which I think is a nonstarter b/c of HTML and XML. ~ was his other suggestion. I don’t know if choosing a different sigil would make it more code-like. Eemeli, you made a list of other candidates.

EAO: I explicitly like D because it does not add a trailing character at the end that we need to care about. Once we’re in code, we’re just always in code; there’s no need for an exit from code. Exit implies there’s something afterward. To me, the dot-keyword is not something that shows up in natural language in my experience, and it’s immediately followed by stuff that looks even more like code. I’m happy going with that. I do think we should go with the dot because that’s what we asked about, that’s what people seem to like. I’m OK with people proposing something else after we land

ECH: As far as dot looking like code, I think you could make up a story about any sigil looking like code. For example, CSS class names having a dot first. Or Clojure doing interop with native languages, using a dot in front of the method name. Inspired by JS in some weird way. No sorry, that’s a dash-dot. Any sigil you use, you can find examples of that. So it’s just a matter of us choosing something and being content with it. With the different sigils, some are mirrored, some not, some are overloaded; dot seems innocuous enough, I’m OK with it. But if there are other concerns, we need to rehash things or just agree to be OK with it and move on.

STA: Two notes: I think dot is fairly common, or at least I’ve seen it before in programming. Won’t be too much of a surprise. Doesn’t assembly use it? (prettified assembly). I did some research and found some bits of history of SGML and HTML and apparently there used to be a language called Script, and that used exactly that syntax, Dot, control keyword, and that would be used for formatting. That became GML and then SGML and HTML. I wonder why that didn’t win - why that went away and HTML / SGML won. Maybe there’s some lessons there to be learned. Tried to find history about that, but wasn’t able to. The other comment is I think the reason why I’m looking for a bracket/wrapping solution is not that I want everyone to suffer when they have to close, but that I would like to be able to tell people that this part here is the declarations and they end here; we already use curly brackets after every input, local, and match. This is an idea I’ve been hoping to maybe discuss as well. We could put that match inside the brackets so that the declaration is a concept in the syntax, rather than being an implicit thing that’s special because the first character of the string is special.

EAO: This is a bit of an offshoot, but I put a link in the chat: https://en.wikipedia.org/wiki/Hope_(programming_language) - Hope, a language from ‘70s and ‘80s that’s a little like Haskell. Notable because it has best-match. There’s actual prior art that I didn’t know we had.

ECH: Stas, I don’t disagree with you; in fact, this is repeating arguments I’ve made before that my ideal preferred syntax would meet the objectives you’re describing. Whatever direction we’ve gone, there have been strong concerns, but you can’t entertain all of them. There’s a set of tradeoffs that we have to be OK with. The problem is that every major objection/concern is treated like a veto. We really have to prioritize or rank what our values are, and maybe we don’t have alignment and the chair has to figure it out. But we had the pre-Seville syntax, then said we don’t like curly braces on simple messages. Now we don’t like the levels of nesting when we start in text mode, and can we not have delimiters on patterns in a complex message, but there’s a whole raft of issues there. Now we’re talking about sigils. Whatever you want to talk about bumps up against other decisions that we’ve made and changed and made. At some point we have to decide what’s most important and accept that there are trade-offs. I don’t think we can continue to bounce around the same decisions. One of the concerns is about iteration hazards or consistency about notation of the pattern. I just want to say that these concerns are bouncing around, conflicting, and somehow we have to resolve the trade-offs.

APP: I think the thing to think about is: if we can make smaller discrete decisions based on some technical choices without re-examining everything in the world unless it’s required. What we’re examining is: how do we get into code mode? From what I’m hearing, we’ve landed on D and are happy with that. If you pull back and want to look at what we have, we are not a programming language, we’re not a templating language, but we are a mini-language; our statements are implicitly closed by the next statement. Our syntax doesn’t have, for example, semicolons or some other delimiter. Somewhere today there was a thread about the arity of match and the arity of match is determined by seeing the first variant. So it’s implicitly closed. We could talk about a change to the match syntax and the question I asked on that thread is: what value accrues to the authors of these things, because the parser doesn’t need it. What value accrues to the authors having that additional piece of syntax? There can be a valid answer to that, but we should be able to answer it and explain the value of doing this or that in the syntax. I agree with Elango that there are inherent tradeoffs, and it should be understandable by people because it’s people who have to author this thing. I’m making a call to say: are we happy with this decision, are we happy with dot? Can go implement it and then talk about the other things on the list.

STA: On the arity issue, maybe we can discuss there, but adding more match keywords is one way to solve it. Allowing input to have arity over 1 is another way. I’m looking for some sort of consistency. We are a mini-DSL with implicit ends of statements. We can accept input with multiple expressions after it. Now we have both approaches where input takes multiple expressions while match doesn’t. On the larger topic, I was a little nostalgic when I browsed through some of our design docs and saw the pre-Seville syntax. It was actually very nice. Had a clear set of requirements and we worked together a lot and created something that worked. I liked that it looked like SQL, Elango doesn’t, but I think it has merits. We changed a requirement and that led us to the new syntax. We’re now like the boy from the Brussels legend putting his finger in the dam. I’m afraid we will end up with some patchwork of a syntax. Change a crucial requirement; deeply I’m a bit sad about all of this, to be honest, but every time we make a decision I see it’s reasonable, so I’m not trying to contest that. Trying to explain why - I’m hearing from you, Elango, that you’re slightly bitter about –

ECH: I’m also nostalgic for the pre-Seville syntax, so I agree with you; the point is, somehow we got here, I think it should at least be documented. I know Addison said he would be upset if we revisited this decision. I want to see something done, and I can live with what we’ve got.

STA: Didn’t mean to say something that wasn’t true. I thought the SQL-like syntax was the right choice for former set of requirements. Now that the requirements have changed, I’m open to look elsewhere, look at proposals from 2 years ago; maybe now a completely different approach is valid. I know that’s not how we get to “done”. But I’m open to ideas like dropping when or experimenting with different code mode introducers. Or mental model of “semantic comment” in front of message that declares variables/selectors. 

EAO: It’s sounding an awful lot like we settled on the dot syntax and now we’re arguing about semantics around it. I’m interested in a followup, if we have consensus on the dot syntax, to talk briefly about when.

APP: Unless anyone objects, I think we’re settling on keywords with dot. That calls into question with when, because now we have a keyword without a dot, or do we want to kill it? I look at this and go, “but we still have the pre-Seville syntax, except for simple messages.” Especially now, b/c we’re removing the brackets around the outside. Are we OK with our consensus?

TIM: could we just add a dot before when?

EAO: I want to kill when - either nothing, or parens if there’s more than one. Or some trailing thing like colon after the keywords. Given what we’re doing now with the syntax, with .local, .input, .match, then .when feels more awkward somehow. Doesn’t feel like it’s right, feels different from input/local/match to me. I’m open to starting off with not having anything there. Just having bare keywords and then pattern.

STA: Experimenting with dropping when is worthwhile if we do it quickly. I think that would make the pattern more like a map of things to things, where maybe the colon – maybe Eemeli’s right. We could consider renaming match. It really works in my mind as part of a sentence: match this when this. Maybe we need input, local, and selector to make this explicit. Another reason to drop or rename when - I realized today that TC39 considered a pattern-matching proposal for JS, which uses match and when but they don’t look like our match and when, which might be confusing.

ECH: I was going to say that I would also like to drop when and replace it with square brackets around the case value tuples, which is what Addision just pasted into the chat:

```
.match {$var} [key] {{pattern}} [*] {{pattern}}
```

I like that look b/c square brackets imply a sequence, so you don’t have to explain it a whole lot. I agree that it would be verbose to have .when. We’ve talked about the different options; that’s just my preference.

APP: Anyone not like square brackets?

STA: All the time or just for multiple selectors?

APP: All the time

EAO: That’s a lot of wrapping of stuff. If the curly braces are supposed to be telling us what’s in the pattern, … 

APP: It could go in the key, though

EAO: Think of all the things that are actually going to go in the key; that’s a much shorter list

APP: It’s replacing the keyword when with brackets

ECH: Those are good points. It’s more concise, consistent, but stated differently, it avoids the iteration hazard of “I’ve got this free-floating thing of arity 1, and now I have to wrap the key…” – I don’t think it’s that big of a deal to always have it. I don’t understand the allergy to that.

EAO: My preference would be for both in the match statement and in the variant keys to use a wrapper like square or round brackets when there’s more than one, but allow when there is only one to not have these brackets around it. My logic is that this would match what other languages that do pattern-matching are doing. In other instances of pattern-matching, they’re doing the matching on a single thing, but it could be an object or a list. It makes sense to me, and furthermore, what I really like about – if we go with a single match statement, having that extra bit of parens or square brackets around the selection is a signal to a reader: “Hang on, this thing is doing selection on multiple things.” Especially if the same wrapping is repeated across the keys of this. I pasted an example in the arity issue discussing this. The value to me of having something like parens or square brackets. The value is to say, “hang on, there’s more than one; it’s not the more common single-selector message.”

APP: I responded on that thread as well. I’m allergic to doing things more than one way; it’s cognitive load. Having more than one way to write the equivalent message makes me nervous and I think it’ll be a source of error rather than a source of strength for people. I tend to not want to add something “but only sometimes”. My thinking was to always bracket the keys; not necessarily add anything to the match statement. How do we want to solve this? Should we take our consensus and do that, and then talk about how to get rid of when separately?

EAO: In the same change, get rid of when completely and then discuss whether something needs to change further. We agree that when is superfluous but we don’t agree yet what it needs to be replaced with, if anything.

APP: That’s a proposal; the counterproposal is to replace it with square brackets.

STA: We could temporarily add dot before when and then take it to a written discussion. We’re making a lot of choices in an oral discussion. 

APP: Consensus is Option D to prefix keywords with `.`. How do we want to incorporate further changes on `when`?

STA: I’m not sure about square brackets yet. Do we all agree that `when` needs to go?

APP: I heard everyone agree to remove `when`.

STA: So can we just remove `when` and then discuss how to resolve the arity question of adding square brackets around the selector value tuples for 1 value vs. multiple (2+) values.

APP: Okay, so we will remove `when` and then see where we go from there. Let’s progress.

**_CONSENSUS_**: Adopt option D (sigil introducer). Adopt `.` as the introducer. Remove the keyword `when`.

There will be further discussion of key decoration.


## Open/close/spannables: where are we?

Let’s discuss the current status and how to proceed with landing this. We will timebox this discussion since it is unlikely we will merge something today.

APP: What we currently have is a document with a ton of alternatives. 

STA: There were two PRs. Eemeli and I met on Friday. We merged one of them, suggesting using the curly HTML-like syntax. There’s another PR that for completeness’ sake - started as a PR adding the do-nothing approach and then use angle-bracket HTML syntax as part of MessageFormat, and then I took it back and added two more ideas there. 

APP: Is there a reason not to merge the proposed design doc? 

STA: All PRs keep the proposed status of the doc, so it’s safe to merge them. If you feel strongly about not discussing four different alternatives at the same time, we can briefly discuss this in the meeting and remove someone. I know last week, the action item was for me and Eemeli to come up with two alternatives.

APP: Having more alternatives is not necessarily evil. Shows you looked under all the rocks. Don’t want to get bogged down in thinking of every possible way of spelling these things. I’m interested in: what’s the syntax we propose to adopt? What are the technical choices we need to make? I think that’s more interesting than debating which sigils, even though that’s probably what this conversation is about

EAO: I’m very interested in this landing. Kind of OK with all the alternatives that Stas is pushing for. My preference is for +/- but I’m fine with any of them. If we want to weed down the list, the options are: either +/-; “open” not having anything at the start and /prefix to that is the end. Effectively, XML except with curly braces. 

APP: Which would eliminate the ability to use an unquoted literal as an operand.

EAO: Specifically, eliminates the ability to use an unquoted non-numerical literal. Numeric literals still work. The third alternative is much the same, except using a ‘#’ at the start: ‘{#’ to start and ‘}/” to end. Self-closing one would be ‘{foo /}’. We can also do a two-stage thing: decide which way to go for open/close, then decide whether to add standalone or rely on registry providing necessary info. The fourth alternative that Stas proposed is kind of like XML, except using square brackets instead of curly braces. If we want to narrow down the space for open/close elements, the one thing to discuss is: are we open to considering square brackets as reserved characters that would need to be escaped in pattern text?

APP: I’m not. Only from the point of view that more escape-y stuff – if you’re doing square brackets, why not angle brackets? Why not just type HTML? I made the argument for why spannables have a place in our syntax, because we would like them to be constructs that you can get as a part. We would like to be able to get the part back, so parser needs to be able to identify it. We can identify angle-bracketed things, but if we’re going to give square brackets multiple meanings… one thing to escape is probably sufficient. Failing that, then we really are just arguing about sigil choice and placement. Eemeli brought up an interesting thing: do we actually need to have a separate standalone, given that openers are effectively standalone when you don’t close them?

STA: I know we made a lot of effort to avoid escaping additional characters, but I think sometimes that effort was well-meant but ill-directed. It’s extremely limiting for our syntax to do that, and our makeshift solution is to come up with additional sigils to differentiate between concepts. I would argue that that’s equally bad, or even worse. I don’t think we should use angle brackets for markup, because that contains friction for angle-bracket languages used in containers, like XML. Square brackets for markup would not run into the host format problem, but could run into the content problem where the content wants to use square brackets verbatim. I don’t have data to back this up, but I think markup is way more common than square brackets as literal text. Eemeli has been saying that a lot; I made a realization that Eemeli has been telling us that markup is very commonly used. This made me dare to suggest this last alternative. It has a lot of pros; works very well w/ rest of the proposal, which stipulates that markup is not expressions; not allowed in declarations or selectors, so it doesn’t get the expression syntax (doesn’t get the curlies).

APP: 40% of the Web is HTML, not “some language”. That’s a commonly observed thing: the #1 language on the web is markup. I buy that argument. I think my concern is: if we replace embedded markup – you can always have embedded angle-bracket markup, which we just don’t recognize, it’s just text. Probably that’s a good thing to be valid. But if you want our code to participate in and recognize spannables as a part and return it to users so you can decorate it, then it needs to participate in our syntax. If you look at HTML, everything resides between angle brackets. There’s no other sigil for something else, and that’s by design. Having more markers is just sigils in a different guise. But we can figure out what we can do here. I want to call out: it sounds like we have a consensus for what to do, but what we’re struggling with is the decoration.

ECH: I lost the thread of who’s arguing for what, but if we’re talking about curly-brace - slash-curly-brace or whatever, that’s OK to me. I agree that the last bits of what Addison said about angle brackets as plain text - that shouldn’t be the default syntax, because HTML-style angle brackets are specific to HTML; may not be the syntax for other types of markup. Had a conversation with Zibi where we were sketching up the inherent problems of authoring messages that contain HTML. There’s the inline vs. the block-level tags; if you put a block-level tag inside a message, that’s quite problematic. Really need to be preprocessing it anyway. The angle bracket question becomes irrelevant, besides being a specific type of markup that we shouldn’t be preferring. All those reasons make me not want to special-case angle brackets.

STA: I agree HTML is not the only markup language; the doc and PRs mention an alternative of using angle brackets but only for the purpose of completeness. There are good reasons documented there already. If you feel there are lacking, the PR is still open, so we can still add it. I don’t think anyone is advocating for using angle brackets: There are two ways: we do nothing with them, and we heard loudly from Eemeli and Mihai that that’s a no-go. So we need to participate; one way would be to implement HTML parsing, but I don’t think anyone wants that. So we don’t have to discuss angle brackets. I agree with Addison that we are discussing decoration. What I like about the current design doc is that it explains the runtime behavior of formatting a string to parts, and there was consensus around that. So we are choosing the visual representation, and all alternatives are strictly about that. The doc has just one version of what happens in the data model and the runtime behavior.

APP: My point in talking about angle brackets in HTML is that I was drawing an analogy with HTML, not suggesting we use angle brackets. The point is that HTML solves all these problems with one set of enclosers.

EAO: The ampersand?

APP: OK. So that’s kind of the analogy I’m using. This is literally a beauty contest. Deciding which is the best one for spannable; I don’t think there’s any disagreement on the rest of it. Do you want to merge this and then have a beauty contest?

STA: HTML had to invent an entire language to describe styles, so it doesn’t solve everything with HTML markup. Can we measure the temperature in this room? Is going for ballots too much? I don’t know what people think about the options presented in the doc?

EAO: One concern about the first alternative Stas is proposing - having the completely unadorned opener, which requires us to get rid of unquoted literals, or at least a large part of them - it’s a little bit like asking, is that even considerable for square brackets? Is that even considerable, getting rid of something like {foo} being a spannable open rather than a placeholder?

APP: I don’t like that, but that’s just me. Do we want to vote on different ones? Who supports +/-? Two of us. Who supports # and /? I see one. Don’t vote multiple times. How about plain and slash, HTML-like? 

Zibi: in ICU4X we use ranked preference…

APP: we do that too, but I’m taking the temperature of the room. was hoping we had a runaway winner, but I’m seeing that we have lukewarm support for – is there a syntax someone cannot live with?

STA: I would be very unhappy with +/-

ECH: I would be as well

Zibi: why are you unhappy?

STA: conflicts with negative numeric literals; makes parsing harder.

RGN: Also don’t like the conflict with unquoted literals?

APP: …

RGN: Ambivalent on that front. I would want the consistency but don’t care how it’s achieved.

APP: So we don’t have an agreement in this room. Is there discussion that would cause us to have an agreement?

ECH: Maybe. Richard, I don’t like the +/- stuff, the - especially, but if we’re going to require literals to be quoted, then maybe that solves the problem.

APP: That makes me nervous, b/c we use literals in keys a lot and I don’t want to quote them there.

ECH: isn’t that different?

APP: Not at the moment

ECH: So if we can make it work out so these things are not in conflict…

APP: Choosing a pair of sigils that don’t conflict would fix that. Sounds like a beauty contest for sigils. # hasn’t found a place to live yet. So we should study this, is what I’m hearing.

EAO: I would possibly ask: does anyone object to # and /?

STA: I don’t object, but I think the other ones are –

EAO: Asking for objections; if we don’t have objections, we have consensus. If there are no objections to # and /, next question is, does anyone object to square brackets?

APP: I do

EAO: does anyone object to unadorned open and slash to close?

APP: I think so

ECH: I’m not sure, but I have some questions

EAO: This sounds an awful lot like a consensus. 

APP: Let’s put it a different way. We’ll have a call next week. Think about it over the week; let’s say that # and / are the candidates. If you have an alternate proposal, make a technical argument for why it’s better. That’ll be the short part of next week’s meeting.

EAO: Should we not have the standalone? Because I get with the + that it feels like it ought to have a -. But if we use # – could we have {#img} to be considered to be a standalone? Can look at the registry and determine it’s supposed to be standalone. Alternative is that we have to have {#img/}, because that’s ugly.

ECH: I agree. The end proposal basically said that. The notion of a standalone is kind of redundant, or it’s implied with the regular placeholder. 

Zibi: I’m only concerned about Eemeli saying there’s going to be registry required –

APP: It’s not part of our spec

Zibi: Then we can’t rely on the registry to know if something will be standalone

APP: It’s implementation-defined. The current spec says that when you go to string, these things disappear unless implementation does otherwise. When you go to parts, you’ll be given the parts and can use them. Can implement some sort of HTML namespacing thing and use that without a registry. We’re not requiring people to install an interpreter for any particular markup language, but they can. If that makes sense. One of the things I like about this is that you can actually implement HTML in this syntax without any registry, assuming people spell the tags and attributes correctly. If they don’t, then you’ve made an element with a funny name and it doesn’t work.

STA: Last week Mihai said that he felt very strongly about standalone. Elango, when you said it’s redundant, you meant that we can use regular placeholders as standalone elements, but I think it’s worth pointing out that there’s also a data model part of that document, and according to that, standalone markup elements would produce different parts than placeholders that are implicitly standalone. But if we change that, we could use :img for standalone elements. Does that make sense?

EAO: My argument here is that if you’ve got a part, an open/close standalone, whatever, you need some processing that knows what to do with it. It has to communicate to all the tools through the registry what it means, what it’s capable of. The other part is the runtime part: when you get the formatted part, you have to know what you’re doing with it. I think the processing there is going to be completely fine either way. Mostly it’s about the fact that we’ll have different expectations in tooling about what to do when you see a source message that only has an “open”, effectively, and doesn’t have a “close”. Will they error there? This can detect in source messages when a developer has left out a “close” that should be there. These are questions that will need to be addressed with a registry and runtime capability, so it will be fine. Otherwise, we need to end up having something like #img/, which I find kind of ugly. HTML is in wide use and does fine with this sort of compromise.

STA: I’m not worried about runtime, because on runtime we will have those functions implemented in a way that produces parts that can be handled by the runtime anyway. The main reason we even introduce open/close/standalone is for tooling that doesn’t support the registry. We anticipate that the registry is an add-on feature that augments the authoring experience but a lot of tooling, especially in the transition period, won’t implement it. We want at least to emulate the current behavior of a lot of workplaces that give you tools to use open/close/standalone. So this is mostly for tooling. I think it’s really interesting to consider whether regular placeholders, like `	$username`, are standalone. If we can answer that, we can use :img, a regular function call, for markup elements.

APP: No, because the default registry will only have certain functions built in, and we’re not going to add HTML to it. Your implementation can plug in an implementation of HTML, or of another markup language. It can say that HTML tags work as spannables and that’s on you. But our default registry won’t have HTML. So then you can’t use it as a normal function. You can use it as an add-on / namespaced function, but can’t use it as a default function because we’re not building HTML ink. That’s why html:something is maybe a good example. Maybe a lot of people will build HTML in, like JS – maybe not JS. There will probably be a fairly reasonable add-on that supports HTML without a prefix.

STA: Would this work? {#html:b}, {/html:b}, {:html:img}

APP: That would work – you would put it in your registry

STA: If we namespace markup, maybe we don’t need standalone syntax

APP: We do namespace markup but maybe we permit people to make a default in their implementation.

EAO: To qualify my earlier statement about consensus, it sounds like we have a consensus on open/close but not necessarily on standalone. I’m OK with this state of affairs. I would be OK with not having standalone; onus is on someone who really wants it to propose a further change adding it once we add open/close

APP: Mihai would say that he really wants standalone. The question is, what’s the sigil?

STA: Or does it need a sigil?

APP: The null sigil is a sigil. Eemeli’s proposal is it’s just open without close. If Mihai feels we need a distinct sigil, what’s the sigil?

STA: One way to find another syntax is to re-use open as standalone, then add some extra logic or processing. I don’t think I’ve made myself clear before, but we already have standalone placeholders: where we just use other things in them. Can we piggyback on them?

APP: Spannable is distinct from placeholders in its behavior. 

EAO: No matter what we do, it will be possible for a user or implementation to define a ‘:’ function that looks like whatever we decide a standalone will look like. It requires processing and runtime processing within MessageFormat to achieve this result. The specific thing we are enabling with open/close is we have a specific syntax that passes through using a specific behavior through MessageFormat processing and if you want to use it, you need a consumer of the formatted-parts output that knows how to use it. This could inform your tools

APP: Participates up to a point, but MessageFormat doesn’t do anything at the moment, only the consumer does

STA: When you review this doc with the additions from the PR, think back to this moment when we keep thinking about standalone and why we can/can’t use regular functions. Give another chance to the alternative using square brackets. I think that’s exactly what they solve: they’re not expressions, they’re not placeholders. Like Eemeli said, you can have {:img} and pretend it’s markup, and it kind of looks like markup.

APP: Next week we’ll declare that our consensus is valid on this. Probably by having a discussion of standalone. Correct?

STA: I think standalone is really hard. The point that Addison, you mentioned about why namespaced functions don’t work for standalone, is not captured in the doc. Essentially I think we should mention the requirement to somehow namespace these. 

APP: There isn’t a requirement, but it is permitted

STA: I mean, requirements for the design – to allow namespacing of those things.

APP: I think the use cases in the design doc cover a bunch of these things

STA: There’s definitely one about using standalone elements, but I mean that the doc right now doesn’t explain why you can’t just use regular un-namespaced functions for standalone.

APP: For the reasons we cited before. You can; there’s no prohibition on writing a function.

STA: Right, but you won’t benefit from our forward-compatibility guarantees

APP: Right. 

## Format to Parts (#463)

Ready to merge as proposed?

APP: I think we want to wait for MIH to be comfortable with the design.

EAO: Yes. We had some discussions, including about BiDi handling. He last posed a challenge about whether a certain type of message was representable. I tried to give an example, and I just need to hear back about that.

APP: That was also my impression; I believe Mihai’s desire for attributed string representation is mappable. You attempted to illustrate that, but I think we should have that discussion with him present before we merge. I want to believe we’re close to then, but let’s do it next week

EAO: if anyone has any concerns about Format to Parts, please raise them now or in the near future

## Quoting and Literals

EAO: Quick question – we have literals and patterns and need to quote both of them. We quote patterns with curly brackets, literals with vertical bars. Can we do the thing that sed does? Accept any non-word characters that don’t conflict with syntax as quotes. This seems to have worked for a few decades with sed, which is dealing with similar problems. 

APP: I think that’s a problem because if we introduce variability in what the symbols are, what happens with downstream tooling? Machine translation tools won’t know what symbol to expect; don’t know what the embedding syntax is going to be. It requires too much knowledge that’s not actually in the string, and therefore what we’ll have is people making mistakes that we don’t know are mistakes. I don’t mind the double curlies for patterns because they’re just the syntax. The pipes are weird, but I think quotes and apostrophes have proven to be a large rock only shallowly under the water in the past. 
TIM: sed not known for readability; hard to explain to users

STA: I think this would probably hurt the syntax. We discussed having multiple ways to do the same things; here we would have many different ways to do the same thing

EAO: Another thing: regarding when, we should talk about pattern delimiters. Syntax looks different now, so pattern delimiters, like quoted-literal delimiters, need discussion

APP: Reintroduces whitespace problem

EAO: Not talking about removing them, just changing them to something else. Write down consensus of why we ended up with this solution

APP: Do we not have that?

EAO: Yes, but that one is abstract. Now having the actual syntax, as we may change variant key syntax, it would be valuable. I agree that we have a consensus on using double curlies, but –

APP: I have bigger fish to fry, maybe. If we’re not going to make a technical change, just write down the reasons, that’s fine, but I’d rather discuss naming, quotes, attributes

EAO: My goal is to change it, b/c I don’t like the double curlies. I like double quotes

APP: We’ve discussed the objections to that; how do we get out of that box?

EAO: That’s why I suggested the sed approach, but I won’t push for it. Just throwing around ideas

APP: Can I make an alternate suggestion? I observe that our syntax is a single-string syntax. We talked about a resource syntax as the next order of “container”. A resource syntax could take a MessageFormat string and decompose it any way it wants. I’m thinking of Puff; Puff will probably not encode MF2 as a string by itself, it will use its JSON syntax and then compile to a MessageFormat string. I think a way out of the box that you’re in is to say “JavaScript message resource format has a structure to it, and it uses double quotes and an actual variant map, and not our syntax directly; when you compile it to a message, it compiles to our syntax.” Does that help?

EAO: No, it’s causing two different problems. First, I would really prefer that the resource syntax not mess around with the contents. The resource syntax should be able to represent MF2 really well but not rehash a discussion on what a message with variants looks like. We’ve spent a lot of time on this discussion and it would be nice to have MF2 not show up in two different places with two slightly different complex-message syntaxes. I don’t think that’s a good result. I still think the resource format is something we get to define in Unicode. It’s been fuzzy to me whether the group on that is officially a CLDR subgroup or not. We haven’t been pushing for it recently, not top-of-mind

APP: All of these questions are out of scope

EAO: Out of scope for this working group, but could have a separate working group under CLDR. If we don’t get that, I need to form a new ECMA TC to handle this, and that feels like much more work.

APP: So the bomb squad has been called to remove my idea from the meeting. I think we’re beyond time today, but that was something to put in your head. Doesn’t have to be part of it. Let’s - deal with quoting in a future call.

STA: Homework? Read open/close doc, then formatted parts

APP: and when syntax

## Topic: AOB?



