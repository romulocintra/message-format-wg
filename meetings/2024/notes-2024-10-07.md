# 7 October 2024 | MessageFormat Working Group Teleconference


### Attendees

- Addison Phillips \- Unicode (APP) \- chair  
- Eemeli Aro \- Mozilla (EAO)  
- Mihai Niță \- Google (MIH)  
- Tim Chevalier \- Igalia (TIM)  
- Elango Cheran \- Google (ECH)  
- Richard Gibson \- OpenJSF (RGN)  
- Matt Radbourne \- Bloomberg (MRR)

###  Previous Attendees

- Addison Phillips \- Unicode (APP) \- chair  
- Eemeli Aro \- Mozilla (EAO)  
- Elango Cheran \- Google (ECH)  
- Mihai Niță \- Google (MIH)  
- Richard Gibson \- OpenJSF (RGN)  
- Tim Chevalier \- Igalia (TIM)  
- 


  
**Scribe:** TIM 

To request that the chair add an *issue* to the agenda, add the label `Agenda+` To request that the chair add an agenda item, send email to the message-format-wg group email.

## [**Agenda**](https://github.com/unicode-org/message-format-wg/wiki#agenda)

To request that the chair add an *issue* to the agenda, add the label `Agenda+` To request that the chair add an agenda item, send email to the message-format-wg group email.

##  Topic: Info Share

(discussion about EAO's upcoming talk about locale identifiers)

##  Topic: Schedule for Release

*The CLDR-TC, ICU-TC and MFWG discussed a schedule for completing the 2.0 release. We propose to complete a dot-release of CLDR called 46.1 with balloting complete on 25 November. Stable (Draft) API in v47. The terminology here needs to be discussed to be clear.*

*This means that we have just six weeks following this one to complete our work.*

APP: EAO and I met with Mark Davis, Annemarie Apple, and a few others, about the possibilities for/schedules for doing an official release of MF2. To summarize, we would like to shoot for doing our release in this calendar year as an LDML 46.1, and then a stable draft release – draft is a specific status in ICU – in version 77 of ICU, which would be March 2025\. This means we need to be done with our work for 46.1, not 47\. A date that was suggested would be balloting complete on the spec by the 25th of November. Not counting this meeting, that leaves six more of these calls before we’d need to be done. I want to throw that out as a proposal and see if we are willing to commit to trying to make these dates.

EAO: We would aim to be done with the spec by mid-November and we would declare our job done and have the spec be in a state where we can and will and should pass it on to the ICU TC, the CLDR TC, and probably the W3C TAG and TC39 TG2 to review and comment on and validate that this is suitable for the stated purposes, so that we can include it in next spring’s release?

APP: We would want to be done in our own minds. One of my side goals is to indoctrinate CLDR and ICU TC so they would rubber stamp our work rather than spending a lot of time commenting. The other reviews would be external in the Technical Preview time frame. They would be post-us-saying-we’re-done. We would respond to feedback, but would be in a position of saying this isn’t going to change.

EAO: On behalf of Unicode, there would not be a block for W3C TAG or TC39 TG2 to review and accept MF2 as a spec, but any input we would get could and should be taken into account, either in the 2.0 release or in future work that we do on the spec?

APP: We would have an opportunity, because the draft version wouldn’t be until 47 / 77\. We would not persist in having weekly meetings working to resolve things.

TIM: Do we have a list of what really needs to be resolved before mid-November. I’m wondering if we know what absolutely needs to be done.

APP: I’ve updated `Things that Need Doing`. It’s relatively short. There are 47 issues. There are some housekeeping issues beyond the main important issues. That’s assuming we get through main issues like function composition

ECH: Are we close to done? I guess so. Maybe it’s not a question of being close to done so much as: is what we have good enough? Is it a good place to put a stake in the sand and say “here’s a release”?

EAO: I’m relatively confident that we are nearly done in the work needed for 2.0. At least from my point of view, a big change of us relaxing the stability policy to allow for later changes that we were previously not supporting makes it much easier to consider some issues in a post-2.0 world, rather than needing to get absolutely everything nailed down and fully agreed on before 2.0. The biggest things we need to figure out – there’s the u-options stuff, some questions around that, and then there’s the composition of `:date` and `:time` values specifically, and the point that Shane raised about wanting to get semantic skeleton considerations into the date/time stuff. One way to resolve that would be to leave it not required but optional, the `:datetime` field formatting options. If we resolve these things to some resolution, then I think we should have this thing sorted. Assuming we agree to the “easy” parts of resolved values and function composition.

APP: I’d add the concept of standard or required and optional functions and options. I think that’s going to be an interesting thing we need to go through. We’ll have to invest some thought to make that concrete. So do we shoot for finishing balloting in the meeting on the 25th?

EAO: Or sooner

APP: If we’re finishing it there, then we have to be done sooner

##  Topic: `resolve-candidate`

*The following issues are proposed for resolve:*  
837

APP: Closed two resolve candidates this morning because they related to the reserved syntax we removed from the ABNF. The other one I have marked as resolved-feedback is feedback from Luca Casonato about “dot cannot be escaped”. This is also a problem because of reserved-statement, but we removed reserved-statement and so I think we can also close this one. Any objection? \[no objections\] That one’s closed.

## Topic: UTF-16 unpaired surrogate handling (895)

*Timeboxed discussion of how to handle unpaired surrogates.*

APP: During the run-up to 46, Tim and Mihai ran into a potential infelicity because `content-char` does not allow unpaired surrogates, but string types in ICU4C/ICU4J do allow it, and their code was checking for unpaired surrogates in text. Seems like substantial overhead. They are asking whether we should change at least the `content-char` in text to allow for unpaired surrogate values in there. I counter-suggested that we add a note permitting implementations to not check for these, even though when we talk about the grammar of a message, we don’t permit it. That’s maybe to help some tools; I can’t think of a case where an unpaired surrogate is any kind of valid data that people would want to have in a message. I think it’s an error. Mihai or Tim, do you want to comment?

MIH: I agree with you that there’s no good use case and it should be an error. The thing is, it does happen. The existing APIs that I know of don’t care, they just pass them through. A lot of string functions in those platforms consider strings to be a bunch of code units, not code points. I’ve seen cases with translated messages that had unpaired surrogates by accident and I don’t think you want to bring down a whole application because of something like that. On the other hand, I’ve seen people abusing unpaired surrogates by putting special markers in the strings. I don’t think these are good use cases, but people do that, and if you want to move between versions of MF2, you’d expect stuff like that to not explode in your face. We should have linters, but reality is what it is.

ECH: Isn’t this a discussion we had a couple years ago? This is where it initially got introduced. I found RCH’s PR, 290, that introduced the change. I know that we talked about this stuff. 

APP: We did. There’s a couple of things here. There’s a practical consideration: do we need to require UTF-16-based implementations to write a bunch of code to check for this. I think my reaction there is that we probably don’t, for text. But disallowing them in names and other things is responsible. I don’t think those things work reliably. I think it probably makes more sense to keep the restriction in some places and allow for implementations to go “this bag of code units, I’m not going to check it”. If you think about a bunch of other places, like encoding, the unpaired surrogate’s going to be a replacement character. I hear you, Mihai, about people abusing code points for bad things, but Unicode has a bazillion private-use and other special things that you can use for that stuff.

EAO: My preference order on solving this is first, to keep the restrictions we currently have; second, to allow for unpaired surrogates in `content-char` but only there; and beyond that, have this suggested text where implementations are free to vary on this. That sets up a bad situation, where switching between implementations breaks someone’s code. This is GIGO and I’m fine with that for content. I’d prefer us to not allow it, but we should do one or the other.

APP: I will briefly note that `content-char` serves as the basis for `quoted-char` and `text-char`, so –

EAO: We would need to change the inheritance between the chars to make this apply only to text content and nothing else. Not literal content either, probably.

APP: I think what you’re suggesting is that `text-char` would allow surrogates

EAO: That’s probably what I meant to say, yes

MIH: Would we be okay to say something like “unpaired surrogates are converted by MF2 to the replacement character”? I’m not going to explode in your face, but if we see this, that’s what we’re going to do; it’s in the spec, it’s not optional.

APP: We would be a USV(?) string, then. You’d have to check for unpaired.

MIH: It’s in the spec right now; we check for the characters to be in those ranges. It’s not about it being difficult to implement. Accounting for reality, not what we would like necessarily.

APP: A few proposals. One to permit them in `text-char`. One to allow them to be replaced with the replacement char. A third is not to do anything. Do we want to make a choice here?

EAO: I’m interested to hear what RCH thinks, given the preceding iteration of this discussion had participation from him

RCH: Mostly I wanted it nailed down. As long as it’s clear and the ability to output strings that are not expressible in a transformation format remains, then it’s fine. Nailing down names is acceptable to me, I don’t know why someone would want the names to be non-conforming, and they don’t affect the output anyway.

EAO: If we are to not error on unpaired surrogates in text, my preference is to just pass them through as they are. Needing to treat them as a special escaped or replacement thing would add complexity that ought to be unnecessary.

RCH: I agree

APP: Would my suggestion work better, which is to say our syntax is rigorous but we allow implementations to ignore it for text?

EAO: No, that’s worse, because we end up with inconsistent implementations and that’s going to be bad. It’s sounding like the least bad option is to allow for unpaired surrogates in text and pass them through as they are.

APP: For all implementations? If we have a UTF-8 implementation, it won’t work.

EAO: Isn’t that handled before the content gets to the MF2 parser?

MIH: Yes, it’s lost before.

RCH: There are implementations where it wouldn’t be possible to express the text content including an unpaired surrogate

APP: We don’t want to require them to support it.

MIH: The surrogates are lost already before that, so…

APP: We should have very careful wording about the handling of unpaired surrogates. Who would like to write the PR?

MIH: I can do that. I raised the issue and asked for it, kind of.

EAO: `text-char` and only `text-char`. `text-char` currently inherits from `content-char`; it might be easier to define them separately.

APP: No, you just OR on the unpaired range.

EAO: Let’s see what MIH comes up with and go from there

##  Resolved Value Implementation (728)

APP: This has spawned several additional bits of work, which we should not consider here. This is the main thing to make “resolved value” a formal term and define it in the way we’ve been discussing, which is to say the value from a function that also includes options and annotation. I have said okay, Tim has said okay, everyone else is sitting on the sidelines. Is this ready to go in? Anyone object to it going in? All right, we’re resolving resolved value.

## Topic: PR Review

*Timeboxed review of items ready for merge.*

| PR | Description | Recommendation |
| ----- | ----- | ----- |
| 859 | \[DESIGN\] Number selection design refinements | Discuss |
| 846 | Add Unicode Registry definition | Discuss (634) |
|  842 | Match numbers numerically | Discuss (Reject) |
| 823 | Define function composition for :number and :integer values | Discuss |
| 814 | Define function composition for date/time values | Discuss |
| 806 | DESIGN: Add alternative designs to the design doc on function composition | Discuss |
| 799 | Unify input and local declarations in model | Discuss (for 14 Oct) |
| 798 | Define function composition for :string values | Discuss |
| 728 | Add "resolved values" section to formatting | Discuss (Merge, Revise summary) |
| 646 | Update spec as if PR 645 were accepted | Discuss |
| 584 | Add new terms to glossary | Discuss |

###  #799 (data model)

APP: Hasn’t received a lot of love lately. 

EAO: I just refreshed this so it doesn’t have any merge conflicts and it’s easier to see the diff. The last comment there is from me replying to a bunch of stuff from Mihai, Elango and Stas about their concerns with respect to this. I think that was in July or something, and it hasn’t advanced from there. I would be very happy to actively ask Mihai and Elango to look at this and discuss it more on that thread during this week. 

MIH: Just one question to clarify. The last comment there is from July 28\. What changed since then?

EAO: There’s a merge from main to that branch, accounting for changes done in the interim. 

MIH: The argument we all tried to make is: what’s the point of doing this? The debate is that there’s no good reason to do this. 

EAO: My request here is for you to review my last comment there and reply to it in the thread, and for us to discuss this next week.

APP: So if I’m hearing correctly, there may be a disagreement about whether to do this and we’re going to have a technical discussion next week about it. 

APP: I think all of the other PRs have to do with resolved value or function composition, which is resolved value. I think an ask for the various authors is to go through and ensure those are consistent. Tim, I don’t know if 646 is germane anymore. I’ll close it. The other one is Simon Clark had some terms he wanted to add to the glossary. I think there are open comments against it. He’s not here to defend himself, so I will ping him.

EAO: I was going to note that I have gone through the number and integer function composition and the date/time/datetime composition PRs, and in order to align them with the text that now landed, the only ones are the ones I proposed today, linkifying the “resolved value” term. Otherwise, these correspond with how we currently define resolved values.

APP: If you’re interested, go through, everyone, and check to see if these are merge-ready. Then I will work on the number selection design piece.

###  Number Selection (#842, #859)

 APP: The outstanding thing we have left is non-integer number selection. And/or any changes to integer number selection. The thing that’s missing there is I have a proposal…

###  bidi changes

APP: Has anyone worked on tests for those?

EAO: I do not have automated tests that validate it.

MIH: I didn’t have time to do anything, due to CLDR/ICU release cycle.

MRR: I can write some tests for that

###  Function composition for number and integer

EAO: As we’ve discussed number and integer function composition for a bit, the text there should align with our current understanding of what a resolved value is, would it be possible to consider that for merging today?

APP: I have some wording things. Maybe that could be considered separately. Do others have a feeling? Any objections? We’ll be back here soon if we change the number selection. \[No objections\] Merging 

EAO: So the next thing is the date and time and datetime composition thing. There, I think the biggest question is whether – what do we do when you have a `:time` value and you feed it to a `:datetime`, and what’s supposed to happen there? The argument I’m proposing in the current PR is to consider it an error. From a `:time` you get a “time-like thing” and the input requirements for a `:datetime` must be a “datetime-like thing”.

APP: I think that’s too stringent, because – there’s classical timekeeping of the milliseconds since epoch/calendar variety, and there’s Temporal-type time types, and a subset of the Temporal-like time types are restricted in that way. But most of the classical ones have ?? for this kind of thing. I think there’s a tripping hazard where if I knowingly pass a `Java.util.date` in my arguments array, and the first time I touch it I annotate it with `:time`, I’m still thinking it’s a `Java.util.date` so I can touch it a second time with a `:datetime`. I can support the idea that a `:time` may throw an error, because it might only be a time. I’m reticent to break classical timekeeping.

EAO: As whatever `:time` can do is a strict subset of what you can do with a `:datetime`, in order to get the effect of what you're looking for, you could and probably should use a `:datetime` on the input. Even if we allow for an error to occur, it means that a reader of a message who doesn’t know how the value from the outside is coming in – it becomes quite dangerous to presume that you could use a `:time` thing in the resolved value of a `:time` annotated expression and then do `:date` operations on it. Where what you ought to be using is `:datetime`.

MIH: I have two arguments. One is – I agree with EAO that that would feel like the correct behavior. On the other hand, there are PLs that don’t even have any special types for date and time, like C. There is in libraries and whatnot, but the language doesn’t have anything in the standard libraries. The other argument is that one can imagine something like `time`… imagine something that takes a time and gives you back a datetime by gluing today’s date to it. I don’t know if that’s the current time function. Similarly for the other way around. I can imagine a function that takes a `time` and gives you back a `datetime`. If you say that’s not the current function `time`, then you’re probably right. I would tend to be tolerant the way APP described.

APP: I would be okay with saying that a `:time` annotated value or a `:date` annotated value may throw a Bad Operand error, or with other function types, because it’s using an implementation-defined type that isn’t supported. For example, a zoned time would throw a Bad Operand error if you tried to `:date` it. That’s an explainable thing and there’s a developer on the end of that stick who would understand why it happens, so the usage pattern is clear. There’s a bunch of operations that we’re kind of ignoring. Coercing time zone on and off values to float and unfloat the value, other things people commonly want to do with time values – MF2 should have a clear story. I built a whole bunch of things for that in past lives that are effective and that I can explain to developers. What I’m afraid of is that there’s a lot of developers in the world and they’re going to be passing in values and are not thinking of annotations as having an effect on the value. We want to make it simple for them to do the right things and possible for them to do the hard things, and that’s why I tend to be reticent about making a hard limit on that when it may just be an expression thing.

EAO: Sounds like there could be a consensus position here where a `:datetime` is always fine with an operand that is coming from a `:datetime`; a `:time` is always fine with an operand coming from `:datetime` or `:time`; and a `:date` is always fine with an operand coming from `:datetime` or `:date`. And if you otherwise combine these resolved values with such annotations, the behavior is implementation-defined and that behavior may be to complain about a bad operand. Does this match what you are proposing?

MIH: I think that would be a good way to put it in the spec. On the other side, I think I would leave this kind of stuff to a linter. In the early days of MF2, we tried not to be opinionated about things that aren’t really i18n. PLs are catching up; JS has a Temporal proposal, Java added something… it’s a stretch for us to be opinionated. Leave this to a linter, enforce what EAO described, but not in the spec.

APP: I don’t know that I agree with linting. EAO’s proposal makes sense because it’s an enumerable thing to say that some implementation-defined types may cause Bad Operand.  Suppose I have a local time value to use a specific type. Does `:datetime` format it or is that a bad operand?

EAO: That’s an implementation-defined behavior.

APP: In your implementation, how would you handle it?

EAO: That would depend on what `Intl.DateTimeFormat` does with whatever value you end up giving it. Given that `Intl.DateTimeFormat` does not currently support such a value, it might depend on exactly what options are declared there.

APP: And I know that that’s how Java works. DateTimeFormat works fine on that unless you ask for a year. 

EAO: Just to clarify, we are talking here about the behavior when combining resolved values rather than formatted values. …That’s behavior we can entirely control in the spec. I want to modify the PR to match what I presented earlier and there’s certainly space there for linters around it. We should be recommending against messages that feed in a `:time` to a `:date` or a `:date` to a `:datetime`. Fundamentally, because the words we’re using imply to a reader that they’re not quite sure what might happen. Even if we leave it as an implementation-defined behavior, we should recommend against it, given that with `:datetime` we can make it happen in a way that’s clear to the reader.

MIH: If the proposal is changed in the way EAO is described, I won’t oppose, but I think it’s overreaching. We should be opinionated about i18n, but this isn’t i18n, it’s bad programming practice. Not my business to handle that. 

APP: I understand about “we’re not going to actually call the function” but I think there’s still room to say “implementation-defined types”. We do say that the resolved value is an implementation-defined type, and that’s generally narrower than the ones that it accepts. Potentially an implementation could say “here’s the list of types I will emit as a resolved value” and if you mix and match, it could result in a bad operand.

EAO: I would like to push back at MIH, I think it’s relevant to translation and l10n. If we have a message with an input that has a `:date`, the resolved value of this input is then used as an operand for a `:datetime`, a translator looking at this can either reasonably presume that the value being formatted is the full original date/time passed in, or it could also be the date with a 00 time on it for the beginning of the day, because it was passed through a `:date` and therefore it’s lost the time. If we allow for this, and particularly if linters don’t complain, we’ll end up with messages that are valid but confusing. This confusion is what I’m seeking most to avoid here.

APP: One observation: the option bag conversation will become interesting here, because that’s one of the other things that composes, and as you mentioned earlier, Shane wants us to lean towards the nascent semantic skeleton thing, and maybe make some of these option bags optional. We want to carefully consider what the options are. That might have an influence there. You’re right that it’s possible to write a message that would effectively filter information out of a date and time value. That is potentially antithetical to our idea of immutability. Translators will generally see placeholders that say what they want to do. They’re not thinking about whether the numbers are going to be 0 or not, they’re thinking about what values are going to appear here.

```  
.input {$date :datetime}  
.local $t = {$date :time}  
.local $d = {$t :date}  
{{What does {$d} at {$t} say?}}  
```

EAO: I’d be happy for us to move on to that discussion and specifically a proposal I’d like to make on the topic, which is that I think we should make for the initial release of the default functions the field options of `:datetime` optional rather than required. So that implementations can implement those, but they are not required to do so.

MIH: So you mean the whole option bag that we have now would be optional?

EAO: Not the whole option bag, the field options. So that excludes some of the options – do we call them locale options? – and the timestyle and datestyle options, which I do think should be required.

MIH: I’m very reluctant to do that. One of the big requirements from Mark Davis, and I agree with it, is to have a way to migrate existing messages to MF2. Existing messages do have equivalent things to what we have here with option bags. MF1 has option bags and the JS formatter has something like this. Even if semantic skeletons land sooner or later, this is kind of well-established stuff that I think would be good to support. People do that today; they use it with existing native APIs.

APP: Let me present Shane’s argument. The best practice at some near-term future moment would be to use skeletons and in particular, the semantic skeletons that aren’t programmable with the weird pattern language ICU has. If that were the best practice, then you want it to be standard and built-in. Any of the existing implementations should be able to handle that because they are going to feed it through the datetime pattern generator behind the scenes. They would have a way to generate that option bag or generate the pattern through local functionality. This would push people toward good things, so therefore it should be standard. There would be these optional options, where we would say how they’re implemented and what the valid values are, and our definition of optional is that you’re not required to implement them, but if you do, do it like this. I could see implementing this as optional and I can see ICU as having it. People have programmed wacky patterns in the past. We don’t currently have picture strings at all. We should address those requirements in the right way, and it might be through optional options. Or if we require it, then everyone has to write that code.

EAO: I was just going to mention that Mihai, I think the requirement for migrating from MF1 content into MF2 is already going to require some set of extensions to the default functions. Skeletons come to mind, picture strings is another, which is entirely valid for MF1. Also the spellout and other functions for number, and the plural offset, which we also do not have. All of these things are required for having MF1-to-MF2 transformability. So us making these options as optional rather than required is not going to increase the burden for any such migration. In particular, as none of these options are directly supported by MF1.

MIH: I’m very split. Picture strings are bad i18n, we rejected them from very early on, and that’s part of the area where we’re entitled to be opinionated. We know it’s bad i18n. This is not about bad i18n, it’s something that – soon it’s going to be best practices, but what’s the definition of soon? Soon can be five years or more. Stuff like this – I don’t know. You mentioned skeletons. Yes, but the skeletons can be mapped 1:1 to the existing option bags. It’s just syntactic sugar. So for MF1, skeletons are supported. I can do the same thing you used to do then today. 

EAO: I’m pretty sure for the majority of cases, that is true, but on the edges, there is functionality in semantic skeleta that’s supported in date/time formatting that is not supported in JS at all. I’ve written a parser for those formats so I could build exactly those option bags, and needing to leave some of the values on the edges, unsupported.

APP:`Intl.DateTimeFormat` is a subset of the functionality present in ICU. So – ICU is more capable of representing a bunch of things, so I’d be unsurprised by that assertion. Two interesting things: one, one of Shane’s things is that the semantic skeleta are limited in what you can represent. They don’t let you do some things that the current skeleton lets you do, like year-month-hour. You can’t say that in a semantic skeleton. That’s maybe an interesting thing. Mihai might be interested to note that when you do the resolved value thing, will ICU skeleton result in resolved options that look like year/month/hour/minute field option bags/ Or will it look like ICU skeleton as the option?

MIH: Everything looks like option bags. They get converted to an ICU skeleton in order to do the formatting, only when you do format-to-string things. So the resolved value would contain option bags.

EAO: I would also like to note that the thing I’m asking for is specifically and only downgrading these field options from required to optional in the initial release. Doing so and still defining them and saying which values they’re supposed to take in makes it possible for us to later change our minds and make them required. The intent with this change would be to give a little time for the work on semantic skeleta to proceed and see if it is on a track to becoming a widely adopted standard. Allowing near-future implementations to not need to implement also the field options if they go the other way out. This is a concern for the ICU4X implementation.

MIH: I don’t know. We’ve been pushing skeletons for many years and people are starting to adopt them. I would be reluctant to push something out and have people say “you can’t even do date and time now.” If I look at the spec and say “I can’t even do this basic stuff I’ve been doing for ten years”, it feels like a bummer. So I think the semantic skeletons are going the right direction, but the thing is, we have existing things in current languages/frameworks that do it a certain way, not just in ICU, in ECMAScript, with Java.time. So you want as little friction as you can. It’s my problem if I want “December at 5 PM”, it’s not an i18n problem.

EAO: I don’t think people are going to make decisions at that sort of level are going to be looking at the spec. They’ll be looking at the implementation that they’re going to be using. For the JS implementation, I’m still going to opt into all of the field options if we make them optional. I’m in a position where I can do that and trust that the situation is going to resolve one way or the other before the `Intl.MessageFormat` part of the language is locked down. I kind of trust and believe that the ICU impl might choose to opt into these options. The ICU impl might include an `icu:skeleton` option directly. These are going to be the interfaces that people need to look at to choose what they’re doing. Rather than us saying in the spec for `:datetime` that these specific options are optional.

MIH: I would say that a big selling point of MF2 is being cross-platform. I can write a bunch of messages and use them in GMail Android, web, and iOS. That’s a big selling point. Having extensions is one thing, another one is icu: options, it’s not portable anymore. You say you’re in a position to do that as optional, I don’t think you are. You might be able to put it in Firefox but not in Chrome. We can’t even guarantee we have a JS implementation that is consistent everywhere. If we have some kind of “draft” namespace that’s the same everywhere, that would help, but I don’t think it’s a good idea.

APP: I think maybe there’s a gap in the phrasing that we’re using. EAO and I have been discussing that in refactoring the function registry, I think we discussed it in previous calls, instead of having a built-in registry and proto-registry, that we have `:number`, which has required things and optional things. Optional options are part of the `:number` spec and if you are an implementor, you are not required to implement them. If you do, then you have to implement them like that. Different than the optional registry. What we’re saying is that every implementation absolutely has to have this set of options, `datestyle` and `timestyle`, and you may have these other ones, and because they’re standardized, toolchains would know what those things meant. They would be built in, but not every implementation would accept those options. The current thing that we have is a brief window in which we could leave out some set of options and therefore not have a whole bunch of options that are ?? deprecated, sort of the way some of the early date stuff in Java is. It’s been deprecated for 30 years and it would be good not to reinvent at-deprecating some of these things if we can. If we think we have to have the option bags, so be it, but then everyone will have to implement it.

EAO: Just thought I’d clarify that when I say “JS implementation” I mean the npm-installable library that is an OpenJS Foundation project, that is in part a polyfill for the JS spec for `Intl.MessageFormat`. So the spec for `Intl.MessageFormat` will need some definition of what it supports. That’s currently at stage 1 and it will take some time to advance through standardization. Separately, the package on npm, which is entirely controlled by me, I can make it accept all of the current options of the formatters. The key is that later on, I can do a major version update to that library where I drop features and switch to a different sort of option bag if semantic skeletons advance sufficiently that they become available on `Intl.DateTimeFormat` in JS, and it starts to make sense for the `Intl.MessageFormat` implementation to only support semantic skeletons and not these field options. This is what I mean by me being able to control what I do in my implementation, and the spec later when it finalizes may say something else.

MIH: Then I want to ask a question. You said these are optional the same way we have certain options on the number and integer formatters. If that’s the case, then this is not in the same bucket with skeletons in ICU, because that’s in a namespace that’s implementation-specific. I’m not sure what we’re proposing yet. Leave them out completely, or say “you can implement this in a namespace”? 

EAO: No; the proposal specifically is that we leave them as they are with the names they currently have, which are namespaced, and say “you may implement these options on `:datetime`”.

MIH: Then we can never take them away

APP: That’s right

EAO: We can never take them away from the spec, but an implementation would not need to support them

MIH: Meaning they’re not portable

EAO: At the moment they’re not portable, correct

APP: We’ve been talking about this a while. I think we’ve talked about the abstract aspects of it and I think we should work on a concrete proposal or maybe even a design doc that says “here are the options”. As we’ve got six weeks to agree. We should have a clearer understanding – bringing this up is good because we should have some level of policy here. We should be parsimonious about what we put in, because everything we put in is required forever. At the same time, we should put in everything that we think is necessary for meaningful adoption.

EAO: For an example of an optional formatter that I think we should define, maybe add on later, is `:list`. List formatting is something that is actively supported in multiple places; we have a decent idea of what it looks like, and we should allow for it to be supported. At the same time, I don’t think we’re in a position where we want to require all implementations to support it.

MIH: I agree with you and I think I even have a list as a proof of concept in one of the unit tests, just to make sure that my implementation can support stuff like that. Certain things will be under the icu namespace, like durations. But list is not in MF1, so not a strong requirement from ICU to say “you have to support that in MF2”. The whole idea of dropping these option bags, I think I would like to take this up with the ICU TC to ask them how they feel about it. In the end, I have to land that thing in ICU itself. 

APP: Let’s see how much we can resolve within the WG in a week. It may be a no-op. 

EAO: Two things. `:duration` like `:list` is another one I’d be happy for us to define as an optional formatter. And then say, if you’re going to do it, do it this way. But we can return to this later as we can expand and work on the core set of functions. Another point is that the intent with what I proposed here is not to drop the field options, but to make them optional, so the question to ICU TC would be whether to support field options or not, as they are spec’d but as optional.

MIH: I really don’t like the idea of making them optional without a namespace. I see there that I can use it in ICU, I will assume it’s standard and portable and I can use it. People don’t use the spec, they’ll be in their editor and copy/paste examples, they’ll see it works on three platforms but the fourth one doesn’t. I’d feel better with the namespace. `icu:` is a big warning that it’s not portable. When it becomes final, you drop the `icu:`. They don’t read the spec and notice that this stuff they’ve copy/pasted that works everywhere else doesn’t work in one place.

EAO: Are you also arguing against defining `:list` and `:duration` as formatters that would be optional?

MIH: At this point, we don’t have time for it, so I’m opposing it based on –

EAO: What you’re proposing about these options is also an argument that could be made about having optional-but-not-required formatters defined at all in the spec.

APP: I think we have to define functions that some implementations are not required to implement. PHP will implement this, perl, awk… they don’t have a list formatter, so they’re not going to do that. Would you be happier, Mihai, if we used the `u:` namespace?

MIH: Kind of; you say it will be deprecated, but it will never really be deprecated

APP: If we specify them, they will always be there, but as you well know, there will be things we can say “but best practices say…” That’s documentation, not implementation. Implementations have to do what the spec says. With `list` as an example, if we specify list formatters, then we want people to do it like X. If we use the `u:` namespace, we can always remove that to make it required by every implementation. Which I assume we would version MF if we did that, because we’d be breaking a bunch of implementations.

MIH: We version the registry, but not MF

APP: We don’t have a registry anymore, but we version specs. There’s that, and things like some of these optional options which we might never promote. We would still say, if you write one, then it looks like this.

MIH: One of the ideas with the machine-readable registry was that you can use it to implement a linter or tooling like IDEs, or integrate it with translation tools. So translators know not to scrub stuff… even `u:`, if I lint, all I can say is “warning: this is not portable.”

APP: I’m going to timebox this. Somebody should take the action item to put the options together in a design doc. Adding a machine-readable registry description is a fine task for us to do in the preview period after 46.1, as something we consider adding on. Unless we think that suddenly becomes a requirement again, I don’t see us doing it now. Does what I’m suggesting sound like the right outcome?

EAO: I’m here to say that if we’re going to define the `u:` namespace as stuff that might or might not work, we should consider whether the `u` letter is useful or if some other prefix would be better, if `x` is appropriate or otherwise. I think we should stick to the plan that Addison has been advancing, which would allow for optional things to be in the root namespace. It sounds like a conversation we’ll need to continue later.

APP: Who wants the action to write a design doc?

EAO: On what part of this?

APP: The options – enumerating them to consider in technical arguments.

EAO: I nominate Shane

APP: He’s not here

MIH: I will try to take some temperature readings in the ICU TC

APP: Are you going to write the design doc?

EAO: I think we really want Shane to do it; because he’s the one who originally wants this. 

EAO: Next actions on me are to update the date/time function composition as we agreed on here. Making the changes sooner will make the later discussion easier. Separately I’ll look at the string composition one. If we could get that to land next week, it would be really good. With an explicitly defined resolved value, we can do much better at defining what a fallback value is.

EAO: We should send to the mailing list a note about this upcoming deadline

APP: I will do that when we hang up

##  Topic: Issue review

[https://github.com/unicode-org/message-format-wg/issues](https://github.com/unicode-org/message-format-wg/issues)

Currently we have 48 open (was 50 last time).

* 3 are (late for) LDML46  
* 15 are for 46.1  
* 15 are `Preview-Feedback`  
* 1 is `resolve-candidate` and proposed for close.  
* 2 are `Agenda+` and proposed for discussion.  
* None are ballots

| Issue | Description | Recommendation |
| ----- | ----- | ----- |
| 865 | TC39-TG2 would like to see completion of the TG5 study | Discuss, Agenda+ |
| 895 | The standard as is right now is unfriendly / unusual for tech stacks that are "native utf-16" | Discuss, Agenda+ |
| 837 | (resolve candidates) | Close |

## Topic: Design Status Review

| Doc | Description | Status |
| ----- | ----- | ----- |
| bidi-usability | Manage bidi isolation | Accepted |
| dataflow-composability | Data Flow for Composable Functions | Proposed |
| function-composition-part-1 | Function Composition | Proposed |
| maintaining-registry | Maintaining the function registry | Proposed,Discuss |
| number-selection | Define how selection on numbers happens | Revision Proposed, Discuss |
| selection-declaration | Define what  effect (if any) the annotation of a selector has on subsequence placeholders | Proposed, Discuss (Agenda+) |
| beauty-contest | Choose between   syntax options | Obsolete |
| selection-matching-options | Selection Matching Options (ballot) | Obsolete |
| syntax-exploration-2 | Balloting of the   revised syntax used in the Tech Preview | Obsolete |
| variants | A collection of   message examples which require a branching logic to handle grammatical   variations | Obsolete   |
| formatted-parts | Define how   format-to-parts works | Rejected |
| quoted-literals | Document the   rationale for including quoted literals in MF and for choosing the | as the   quote symbol | Accepted |
| builtin-registry-capabilities | Tech Preview   default registry definition | Accepted |
| code-mode-introducer | Choose the   pattern for complex messages | Accepted |
| data-driven-tests | Capture the planned approach for the test suite | Accepted |
| default-registry-and-mf1-compatibility | Default Registry and MF1 Compatibility | Accepted |
| delimiting-variant-patterns | Delimiting of Patterns in Complex Messages (Ballot) | Accepted |
| error-handling | Decide whether and what implementations do after a runtime error | Accepted |
| exact-match-selector-options | Choose the name for the “exact match” selector function (this is `:string`) | Accepted |
| expression-attributes | Define how attributes may be attached to expressions | Accepted |
| open-close-placeholders | Describe the use   cases and requirements for placeholders that enclose parts of a pattern | Accepted |
| overriding-extending-namespacing | Defines how   externally-authored functions can appear in a message; how externally   authored options can appear; and effect of namespacing | Accepted |
| pattern-exterior-whitespace | Specify how   whitespace inside of a pattern   (at the start/end) works | Accepted |
| string-selection-formatting | Define how   selection and formatting of string values takes place. | Accepted |
| variable-mutability | Describe how   variables are named and how externally passed variables and internally   defined variables interact | Accepted |

## Topic: AOB?

